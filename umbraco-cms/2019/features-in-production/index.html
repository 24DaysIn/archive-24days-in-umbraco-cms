<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">


	<title>Features in Production</title>
<meta name="description" content="">

	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="/assets/24days-archive.css">
	<link rel="apple-touch-icon" href="/assets/24days-touch-icon.png">
		
	
	
</head>
<body>
	



<section class="page"><main class="article"><header><h1 class="header">Features in production</h1>
      <p class="byline"> by Thomas Morris, <span class="pubdate">posted on <time datetime="2019-12-18">Dec 18, 2019</time></span></p></header><div class="notification warning">
      <h2>Heads Up!</h2>
      <p>
					This article is several years old now, and much has happened since then,
					so please keep that in mind while reading it.
				</p>
    </div>
    <div class="content-column">
      <p class="teaser">When deploying features or new changes to our websites, we might not want them to be available to all users at once. It would be nice if we could slowly introduce new features to our users. We might even want to completely disable them and have them there in secret. In this article, I'm going to present a few different ways in which you can release features into production, even when they might not be fully complete.</p>
<h2>Background</h2>
<p class="intro">Before we look into the ways in which we can get our features into production, it's useful to think about how we might have typically developed new changes in our website before a release.</p>
<p>One of the most common ways is to use feature branches in a <a href="https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow">gitflow scenario</a>, where you would build your new feature, deploy to a test environment and then try and merge those changes with anything else that has changed in the meantime. You'll probably bundle a number of changes together and then release those to production.</p>
<p>Some of the issues at this stage might be that you've got a tricky merge, you've tested something in isolation and when you bring it all together other issues might arise. You also haven't really trialled those changes with actual users, so those changes may not be desired or there could be problems with how it all works.</p>
<h2>Benefits and options</h2>
<p>Therefore, it's probably a good idea to highlight some of the benefits as to why you might want to integrate your new changes sooner rather than later.</p>
<ul>
<li>Your features get into production quicker</li>
<li>You can get feedback earlier</li>
<li>You can test things in reduced quantities</li>
<li>You should end up with a better product</li>
<li>Your client will be happy</li>
</ul>
<p>You might have seen reasons like this elsewhere, and that's because they actually run true for agile development and the scrum process, which in turn is a good fit for <a href="https://continuousdelivery.com/">continuous delivery</a>. A notion that your app is always in a deliverable state, since any new changes have been safely integrated somehow.</p>
<p>On to the ways in which we can enable our changes...</p>
<h3>App settings</h3>
<p>One of the easiest ways is to define them in your web.config, application settings somewhere, or provide settings in your Umbraco solution to switch features on and off. You'll need to check this setting within your code before including the new changes for your users.</p>
<p>This can be done with a feature helper, which can query the app setting and then return a true or false as to whether the new changes should be included or not.</p>
<pre><code class="language-csharp">public static class FeatureHelper
{
    public static bool IsFeatureEnabled(string featureFlag)
    {
        // check if we have enabled functionality via web.config
        bool.TryParse(ConfigurationManager.AppSettings.Get(featureFlag), out var setting);
        return setting;
    }
}</code></pre>
<p>If you'd like to turn off entire controllers or action methods, one of the ways in which you can do that is via the use of <a href="https://docs.microsoft.com/en-us/aspnet/mvc/overview/older-versions-1/controllers-and-routing/understanding-action-filters-cs">attributes</a>. These will decorate your actions and apply the filter before any of the other code is run. In the attribute logic, it will call our feature helper to determine whether or not a feature should be applied.</p>
<pre><code class="language-csharp">public class FeatureAttribute : ActionFilterAttribute
{
    public string ConfigVariable { get; set; }

    public FeatureAttribute(string configVariable)
    {
        ConfigVariable = configVariable;
    }

    public override void OnActionExecuting(ActionExecutingContext filterContext)
    {
        // if the feature is not enabled, then redirect to 404
        if (!FeatureHelper.IsFeatureEnabled(ConfigVariable))
        {
            filterContext.HttpContext.Response.Redirect("/404/");
        }
        else
        {
            base.OnActionExecuting(filterContext);
        }
    }
}</code></pre>
<p>This allows for features to be controlled relatively easy in terms of when it is available, but it's an all or nothing solution which might not be desired when you want to tentatively introduce customers to your new feature.</p>
<h3>Session</h3>
<p>We can apply changes based on a user's session data, which could be enabled via a campaign to help with testing. Ask for people to click a link and become part of the session. You can then trigger an update that will kill off any session data if there are issues. The code above that we used for checking app setting can be amended to apply with session data.</p>
<pre><code class="language-csharp">public static class FeatureHelper
{
    public static bool IsFeatureEnabled(string sessionFlag)
    {
        // check if we have a valid session to enable functionality
        var sessionVar = HttpContext.Current?.Session[sessionFlag];
        if (sessionVar == null)
        {
            return false;
        }

        return bool.Parse(sessionVar.ToString());
    }
}</code></pre>
<p>This is great for ad hoc testing, as everything can return to normal after the session. This is ideal if you don't have an account system set up, but it is helpful if you can target or segment your users if you have a hypothesis you want to test.</p>
<p>A/B testing would be a good scenario here. One set of users could get the feature enabled and the other set could continue as normal to see if anything is improved, if your feature relates to performance or conversions. It's important that you can define what improvement looks like or can at least get some feedback from your users.</p>
<h3>User preference</h3>
<p>If you do have an account section, you could provide the user the choice as to whether they want to opt in to a newly released feature that you might want to test further before enabling for all. You would need to check against the current logged in user as to whether or not they would like to see those changes.</p>
<p>In Umbraco, you could define this as a member property or <a href="https://our.umbraco.com/Documentation/Getting-Started/Data/Members/#creating-member-groups" data-anchor="#creating-member-groups">membership group</a> so you can see within the backoffice which users have enabled your feature and segment your users that way. If your changes are more granular, then using properties is probably preferred.</p>
<p><em>Just to note, for members in Umbraco there is the concept of role based access, which is tied with membership groups, so could be an option if you wanted to hook in that way instead. This uses .NET authorisation under the hood.</em></p>
<p><img style="width: 500px; height: 238.01560758082496px;" src="/archive/media/2019/umbraco-membership-features.png?width=500&amp;height=238.01560758082496" alt="A list of features for an Umbraco member" data-udi="umb://media/d4c2ee7a98ba4daba85d881afe3c9ad6"></p>
<p>This puts the control on to your users, and they are more likely to be actively engaged with a feature and also understand that there may be issues. If they're not happy with how it works, then they can opt back out and carry on as normal. Within your website, you can provide an option for feedback based on whether a new feature has been turned on. They can submit reports and you can gain some quality insight as to how your users are actually using your changes.</p>
<h3>Deployment slots</h3>
<p>If you're doing your deployments via Azure App Services, then another option at your dispense, is to use <a href="https://docs.microsoft.com/en-us/azure/app-service/deploy-staging-slots#route-traffic" data-anchor="#route-traffic">deployment slots</a>. The main use case for this is to run a staging slot alongside your live slot, and to swap them when doing a deployment to ensure that you've tested your changes, warmed up your site beforehand and traffic is switched over without downtime.</p>
<p>There is another benefit to it though, in that it can allow you to drive traffic to either slot based on a percentage. That way you can test with 20% of users before rolling out to the other 80% and this is managed through deployment. You can do similar with traffic manager or other load balancing rules.</p>
<p><img style="width: 500px; height: 207.1778140293638px;" src="/archive/media/2019/deploymentslots-routetraffic.png?width=500&amp;height=207.1778140293638" alt="Azure deployment slots" data-udi="umb://media/5aac0ddbe8394041a1c0f056d971e75d"></p>
<p>With this option, it's even more important that you can provide suitable metrics and logs to determine how your new changes are performing. Without reasonable guidance, you're in the dark as to whether or not it's a good idea to roll out.</p>
<h3>Features as a service</h3>
<p>With the rise of microservices, why not make use of a service that can handle our features? One of those services is <a href="https://launchdarkly.com/">LaunchDarkly</a>, which provides a dashboard for your features and has a number of libraries (inc. JS and .NET) that you can integrate with. As a solution, it'll allow you to get a full feature management tool pretty quickly, and one that should provide plenty of options albeit at a price. Useful to consider, and there may well be others out there. The concepts should still be the same as we've outlined in this article.</p>
<h2>Conclusion</h2>
<p>Testing features in production is a big part of continuous improvement and ties in well with the continuous development way of doing things. You can deliver changes quicker and have greater confidence in when a feature is enabled for all. Ideally, you can ramp up usage in a controlled manner.</p>
<p>You can gain feedback on your changes from real users and scenarios, which may in turn provide much greater insight as to how something works. The end goal being that your changes have been well integrated and are of better quality overall.</p>
    </div><footer><ul class="tags">
        <li><a rel="tag" href="https://24days.in/umbraco-cms/tags/configuration/" title="See all articles tagged with Configuration">Configuration</a></li>
        <li><a rel="tag" href="https://24days.in/umbraco-cms/tags/developer/" title="See all articles tagged with Developer">Developer</a></li>
      </ul></footer><section class="bios"><div class="bio">
        <div class="gravatar" title="Thomas Morris"><img src="//gravatar.com/avatar/cf739411bb0692dd09327560f3c5580d.jpg?d=mm&amp;s=150" srcset="//gravatar.com/avatar/cf739411bb0692dd09327560f3c5580d.jpg?d=mm&amp;s=300 2x" width="150" height="150"></div>
        <h1>Thomas Morris</h1>
        <p>Thomas is on Twitter as <a href="//twitter.com/mozzydev" title="Thomas Morris on Twitter" rel="author">@mozzydev</a></p>
      </div></section><section class="comments"><div id="disqus_thread"></div></section></main><nav class="dates-navbar"><a href="/umbraco-cms/2019/" class="home-link"><span class="scr-text">Home</span></a><ol>
      <li><a href="/umbraco-cms/2019/hello-heartcore/" title="Hello Heartcore"><span class="scr-text">Hello Heartcore</span></a></li>
      <li><a href="/umbraco-cms/2019/setting-the-stage/" title="Setting the stage"><span class="scr-text">Setting the stage</span></a></li>
      <li><a href="/umbraco-cms/2019/evolution-of-the-umbraco-developer/" title="Evolution of the Umbraco Developer"><span class="scr-text">Evolution of the Umbraco Developer</span></a></li>
      <li><a href="/umbraco-cms/2019/how-to-keep-up/" title="How To Keep Up"><span class="scr-text">How To Keep Up</span></a></li>
      <li><a href="/umbraco-cms/2019/front-end-or-back-end/" title="Front-End or Back-End"><span class="scr-text">Front-End or Back-End</span></a></li>
      <li><a href="/umbraco-cms/2019/know-better-do-better/" title="Know Better, Do Better"><span class="scr-text">Know Better, Do Better</span></a></li>
      <li><a href="/umbraco-cms/2019/umbraco-sass-loops/" title="Umbraco Sass loops"><span class="scr-text">Umbraco Sass loops</span></a></li>
      <li><a href="/umbraco-cms/2019/estimations/" title="Estimations"><span class="scr-text">Estimations</span></a></li>
      <li><a href="/umbraco-cms/2019/getting-to-grips-with-umbraco-8/" title="Getting to grips with Umbraco 8"><span class="scr-text">Getting to grips with Umbraco 8</span></a></li>
      <li><a href="/umbraco-cms/2019/separation-and-integration/" title="Separation and Integration"><span class="scr-text">Separation and Integration</span></a></li>
      <li><a href="/umbraco-cms/2019/hybrid-headless-approach/" title="Hybrid Headless Approach"><span class="scr-text">Hybrid Headless Approach</span></a></li>
      <li><a href="/umbraco-cms/2019/rapid-prototyping/" title="Rapid Prototyping"><span class="scr-text">Rapid Prototyping</span></a></li>
      <li><a href="/umbraco-cms/2019/why-use-umbraco/" title="Why Use Umbraco"><span class="scr-text">Why Use Umbraco</span></a></li>
      <li><a href="/umbraco-cms/2019/multilingual-websites-in-umbraco-8/" title="Multilingual websites in Umbraco 8"><span class="scr-text">Multilingual websites in Umbraco 8</span></a></li>
      <li><a href="/umbraco-cms/2019/responsive-hybrid-navigation/" title="Responsive Hybrid Navigation"><span class="scr-text">Responsive Hybrid Navigation</span></a></li>
      <li><a href="/umbraco-cms/2019/contentfinder-in-umbraco-8/" title="ContentFinder in Umbraco 8"><span class="scr-text">ContentFinder in Umbraco 8</span></a></li>
      <li><a href="/umbraco-cms/2019/get-to-know-your-editor/" title="Get to know your editor"><span class="scr-text">Get to know your editor</span></a></li>
      <li class="selected"><a href="/umbraco-cms/2019/features-in-production/" title="Features in production"><span class="scr-text">Features in production</span></a></li>
      <li><a href="/umbraco-cms/2019/umbraco-packages-2019/" title="Umbraco Packages 2019"><span class="scr-text">Umbraco Packages 2019</span></a></li>
      <li><a href="/umbraco-cms/2019/aad-and-headless/" title="AAD and Headless"><span class="scr-text">AAD and Headless</span></a></li>
      <li><a href="/umbraco-cms/2019/vue-plus-push/" title="Vue + Push"><span class="scr-text">Vue + Push</span></a></li>
      <li><a href="/umbraco-cms/2019/umbraccess/" title="Umbraccess"><span class="scr-text">Umbraccess</span></a></li>
      <li><a href="/umbraco-cms/2019/dashboards-plus-migration/" title="Dashboards + Migration"><span class="scr-text">Dashboards + Migration</span></a></li>
      <li><a href="/umbraco-cms/2019/chocolates-plus-images/" title="Chocolates + Images"><span class="scr-text">Chocolates + Images</span></a></li>
      <li><a href="/umbraco-cms/2019/package-team-favorites/" title="Package Team Favorites"><span class="scr-text">Package Team Favorites</span></a></li>
    </ol></nav></section>


	<script type="module" src="/assets/ipuzzler.js"></script>
	<script defer src="/assets/libs.min.js"></script>
	<script defer src="/assets/app.js"></script>
	
</body>
</html>
